{
	// Place your snippets for cpp here. Each snippet is defined under a snippet name and has a prefix, body and 
	// description. The prefix is what is used to trigger the snippet and the body will be expanded and inserted. Possible variables are:
	// $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. Placeholders with the 
	// same ids are connected.
	// Example:
	// "Print to console": {
	// 	"prefix": "log",
	// 	"body": [
	// 		"console.log('$1');",
	// 		"$2"
	// 	],
	// 	"description": "Log output to console"
	// }

	//多组输入开头
	"saber": {
		"prefix": "saber",
		"body": [
			"#include <bits/stdc++.h>",
            "#define Avalon 0",
            "using Saber = void;",
			"using namespace std;",
			"using ll = long long;",
			"const int N = 1e6 + 5;   //remember to modify the range of the data!!",
			"const int mod = 1e9 + 7;",
			"const int inf = 0x3f3f3f3f;",
			"",
			"int n, m, T;",
			"",
			"int main(Saber)",
			"{",
			"    cin >> T;",
			"",
			"    while(T--)",
			"    {",
			"        $0",
			"    }",
			"",
			"    return Avalon;",
			"}"
		],
		"description": "isaber's componets"
	},

	//normal
	"isaber": {
		"prefix": "isaber",
		"body": [
			"#include <bits/stdc++.h>",
            "#define Avalon 0",
            "using Saber = void;",
			"using namespace std;",
			"using ll = long long;",
			"const int N = 1e6 + 5;   //remember to modify the range of the data!!",
			"const int mod = 1e9 + 7;",
			"const int inf = 0x3f3f3f3f;",
			"",
			"int n, m, T;",
			"",
			"int main(Saber)",
			"{",
			"    $0",
			"",
			"    return Avalon;",
			"}"
		],
		"description": "isaber's componets"
	},

	//计算几何开头
	"iisaber": {
		"prefix": "iisaber",
		"body": [
			"#include <bits/stdc++.h>",
            "#define Avalon 0",
            "using Saber = void;",
			"using namespace std;",
			"using ll = long long;",
			"const int N = 1e6 + 5;   //remember to modify the range of the data!!",
			"const int mod = 1e9 + 7;",
			"const int inf = 0x3f3f3f3f;",
			"const int maxp = 1e6 + 5;",
			"const double Pi = acos(-1.0);",
			"const double eps = 1e-8;",
			"// #define double long double //用的时候注意输入输出用 %Lf",
			"",
			"int n, m, T;",
			"",
			"int main(Saber)",
			"{",
			"    $0",
			"",
			"    return Avalon;",
			"}"
		],
		"description": "isaber's componets"
	},

	"loop": {
		"prefix": "loop",
		"body": [
			"for(int i = 1; i <= n; i++)",
			"$0"
		]
	},

	"file": {
		"prefix": "file", 
		"body": [
			"freopen(\"../data/in.txt\", \"r\", stdin);",
			"// freopen(\"../data/out.txt\", \"w\", stdout);",
		]
	},

	"quickpow" : {
		"prefix": "quickpow",
		"body": [
            "ll qpow(ll a, ll p)",
            "{",
            "    ll res = 1;",
            "    while(p)",
            "    {",
            "        if(p & 1)",
            "            res = res * a % mod;",
            "        a = a * a % mod;",
            "        p >>= 1;",
            "    }",
            "    return res;",
            "}",
		]
	},

	"out" : {
		"prefix": "out",
		"body": "\" \\n\"[i == n];",
	},

	"Combinatorics" : {
		"prefix": "Combinatorics",
		"body": [
            "vector <Z> fac, facinv;",
            "$0Remember to initialize",
            "void init (int n)",
            "{",
            "    fac.resize(n + 1), facinv.resize(n + 1);",
            "    fac[0] = facinv[0] = 1;",
            "    for(int i = 1; i <= n; i++)",
            "        fac[i] = fac[i - 1] * i;",
            "    facinv[n] = fac[n].inv();",
            "    for(int i = n; i > 1; i--)",
            "        facinv[i - 1] = facinv[i] * i;",
            "}",
            "Z C(int a, int b)   //C^a_b",
            "{",
            "    if(a > b || a < 0 || b < 0)",
            "        return 0;",
            "    return fac[b] * facinv[a] * facinv[b - a];",
            "}",
            "Z A(int a, int b)   //A^a_b",
            "{",
            "    if(a > b || a < 0 || b < 0)",
            "        return 0;",
            "    return fac[b] * facinv[b - a];",
            "}",
                    ]
	},

	"Sieve" :{
		"prefix": "Sieve",
		"body": [
			"bool isprime[N];",
			"int prime[N], primecnt;",
			"$0Remember to initialize",
			"void init(void)",
			"{",
			"    for(int i = 2; i < N; i++)",
			"    {",
			"        if(!isprime[i])",
			"            prime[++primecnt] = i;",
			"        for(int j = 1; j <= primecnt && 1ll * i * prime[j] < N; j++)",
			"        {",
			"            isprime[i * prime[j]] = 1;",
			"            if(i % prime[j] == 0)",
			"                break;",
			"        }",
			"    }",
			"}",
		]
	},

	"exgcd" :{
		"prefix": "exgcd",
		"body": [
			"ll exgcd(ll a, ll b, ll &x, ll &y)",
			"{",
			"    if(b == 0)",
			"    {",
			"        x = 1, y = 0;",
			"        return a;",
			"    }",
			"    ll g = exgcd(b, a % b, y, x);",
			"    y -= a / b * x;",
			"    return g;",
			"}",
		]
	},
	
	"TLE" : {
		"prefix" : "TLE",
		"body": [
			"头文件 windows.h ",
			"DWORD start_time = GetTickCount();",
			"DWORD end_time = GetTickCount();",
			"cout << \"Time: \" << (end_time - start_time) << \"ms\"<< '\\n';",
		]
	},

	//segment tree
	"seg" : {
		"prefix": "seg",
		"body": [
			"#define lson (k << 1)  //使用前先看作用域里有无 k",
			"#define rson (k << 1 | 1)",
			"//开4倍空间",
			"void pushup()",
			"{",
			"",
			"}",
			"",
			"void pushdown()",
			"{",
			"",
			"}",
			"",
			"void build(int k, int l, int r)",
			"{",
			"    if(l == r)",
			"    {",
			"",
			"        return;",
			"    }",
			"    int mid = l + r >> 1;",
			"    build(lson, l, mid);",
			"    build(rson, mid + 1, r);",
			"    pushup();",
			"}",
			"",
			"void update(int k, int c, int x, int y, int l, int r)",
			"{",
			"    if(x <= l && y >= r)",
			"    {",
			"        return;",
			"    }",
			"    int mid = l + r >> 1;",
			"    pushdown();",
			"    if(x <= mid)",
			"        update(lson, c, x, y, l, mid);",
			"    if(y > mid)",
			"        update(rson, c, x, y, mid + 1, r);",
			"    pushup();",
			"}",
			"",
			"void query(int k, int x, int y, int l, int r)",
			"{",
			"    if(x <= l && y >= r)",
			"    {",
			"        return;",
			"    }",
			"    int mid = l + r >> 1;",
			"    pushdown();",
			"    if(x <= mid)",
			"        query(lson, x, y, l, mid);",
			"    if(y > mid)",
			"        query(rson, x, y, mid + 1, r);",
			"    pushup();",
			"    return;",
			"}",
		],
		"description": "Segment Tree"
	},

	//链式前向星
	"edge" : {
		"prefix": "edge",
		"body": [
			"int head[N], tot;",
			"struct node",
			"{",
			"    int next, to;",
			"} e[N << 1];",
			"void add(int from, int to)",
			"{",
			"    e[++tot] = {head[from], to};",
			"    head[from] = tot;",
			"}",
		],
	},

	//Persistent Segment Tree
	"persistent" : {
		"prefix": "pst",
		"body": [
			"int root[N], cnt;",
			"struct node",
			"{",
			"    int l, r;",
			"} t[N << 5];",
			"",
			"void pushup()",
			"{",
			"",
			"}",
			"",
			"void build(int &k, int l, int r)",
			"{",
			"    k = ++cnt;",
			"    if(l == r)",
			"    {",
			"        return;",
			"    }",
			"    int mid = l + r >> 1;",
			"    build(t[k].l, l, mid);",
			"    build(t[k].r, mid + 1, r);",
			"    pushup();",
			"}",
			"",
			"void update(int &k, int pre, int c, int x, int l, int r)",
			"{",
			"    k = ++cnt;",
			"    t[k] = t[pre];",
			"    if(l == r)",
			"    {",
			"        return ;",
			"    }",
			"    int mid = l + r >> 1;",
			"    if(x <= mid)",
			"        update(t[k].l, t[pre].l, c, x, l, mid);",
			"    else",
			"        update(t[k].r, t[pre].r, c, x, mid + 1, r);",
			"    pushup();",
			"}",
			"",
			"void query(int k, int x, int y, int l, int r)",
			"{",
			"    if(x <= l && y >= r)",
			"    {",
			"",
			"        return ;",
			"    }",
			"    int res = 0;",
			"    int mid = l + r >> 1;",
			"    if(x <= mid)",
			"        query(t[k].l, x, y, l , mid);",
			"    if(y > mid)",
			"        query(t[k].r, x, y, mid + 1, r);",
			"}",
		],
	},

    //io流取消和scanf的绑定
    "ios" : {
        "prefix": "ios",
        "body": [
            "//切勿再用scanf();",
            "std::ios::sync_with_stdio(false);",
            "std::cin.tie(0);"
        ]
    },

    //Binary Index Tree
    "bit": {
        "prefix": "bit",
        "body": [
            "ll t[N];",
            "",
            "void insert(int i, ll c)",
            "{",
            "    for(; i < N; i += i & -i)",
            "        t[i] += c;",
            "}",
            "",
            "ll query(int i)",
            "{",
            "    ll res = 0;",
            "    for(; i > 0; i -= i & -i)",
            "        res += t[i];",
            "    return res;",
            "}",
        ],
    },
    
    //模mod的剩余类环(模数是质数时构成一个有限域)
    "Z": {
        "prefix": "Z",
        "body": [
            "// assert -mod <= x < 2 * mod",
            "int norm(int x)",
            "{",
            "    if(x < 0)",
            "        x += mod;",
            "    if(x >= mod)",
            "        x -= mod;",
            "    return x;",
            "}",
            "//模mod的剩余类环(模数是质数时构成一个有限域)",
            "struct Z",
            "{",
            "    int x;",
            "    Z(int x = 0):x(norm(x)) {};",
            "    Z(ll x): x(norm(x % mod)) {};",
            "    int val() const ",
            "    {",
            "        return x;",
            "    }",
            "    Z operator -() const ",
            "    {",
            "        return Z(norm(mod - x));",
            "    }",
            "    Z & operator +=(const Z &rhs) ",
            "    {",
            "        x = norm(x + rhs.x);",
            "        return *this;",
            "    }",
            "    Z & operator -= (const Z &rhs)",
            "    {",
            "        x = norm(x - rhs.x);",
            "        return *this;",
            "    }",
            "    Z & operator *= (const Z &rhs)",
            "    {",
            "        x = ll(x) * rhs.x % mod;",
            "        return *this;",
            "    }",
            "    Z & operator /= (const  Z &rhs)",
            "    {",
            "        return *this *= rhs.inv();",
            "    }",
            "    friend Z operator +(const Z &lhs, const Z &rhs)",
            "    {",
            "        Z res = lhs;",
            "        res += rhs;",
            "        return res;",
            "    }",
            "    friend Z operator -(const Z &lhs, const Z &rhs)",
            "    {",
            "        Z res = lhs;",
            "        res -= rhs;",
            "        return res;",
            "    }",
            "    friend Z operator *(const Z &lhs, const Z &rhs)",
            "    {",
            "        Z res = lhs;",
            "        res *= rhs;",
            "        return res;",
            "    }",
            "    friend Z operator /(const Z &lhs, const Z &rhs)",
            "    {",
            "        Z res = lhs;",
            "        res /= rhs;",
            "        return res;",
            "    }",
            "    Z pow(int p) const",
            "    {",
            "        if(x == 0)",
            "            return 0;",
            "        Z res = 1, a = x;",
            "        while(p)",
            "        {",
            "            if(p & 1)",
            "                res *= a;",
            "            a *= a;",
            "            p >>= 1;",
            "        }",
            "        return res;",
            "    }",
            "    Z inv() const",
            "    {",
            "        assert(x != 0);",
            "        return (*this).pow(mod - 2);",
            "    }",
            "    friend istream & operator >> (istream &in, Z &rhs)",
            "    {",
            "        ll v;",
            "        in >> v;",
            "        rhs = Z(v);",
            "        return in;",
            "    }",
            "    friend ostream & operator << (ostream &out, const Z &rhs)",
            "    {",
            "        return out << rhs.x;",
            "    }",
            "};",
        ]
    },
    
    "header" :{
        "prefix": "header",
        "body": [
            "#include <iostream>",
            "#include <cstdio>",
            "#include <algorithm>",
            "#include <cstring>",
            "#include <vector>",
            "#include <cmath>",
            "#include <cassert>"
        ]
    }
}